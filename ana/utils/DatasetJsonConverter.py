"""Module DatasetJsonConverter
*************************

Convert the sentence dataset generated by the annotation tool to a set of json
document. One json document per contract.
These documents can then be added to the db (MongoDB)

:author: Nathan Ramoly
"""

import os
import csv
import json
from datetime import date

DELIM = ","

def createJsonContract(title, desc=""):
    """
    Create a JSON contract including an instance.
    """

    instance = {
        "date": str(date.today()),
        "description": "This instance carries both original, corrected and generated clauses.",
        "clauses": []
        }

    contract = {
        "title": title,
        "description": desc,
        "instances": [instance]
    }

    return contract

def loadSentence(clId, sentId, sentDir, pathSeLabel, charOffset):
    strClId = str(clId).zfill(4)
    strSentId = str(sentId).zfill(3)

    strSentFId = strClId+"_"+strSentId

    # Get text content
    text = ""
    with open( os.path.join(sentDir, strSentFId+".txt"), 'r', encoding="utf8") as f:
        text = f.read()

    # Get annotation
    anom = ""
    policy = ""
    with open(pathSeLabel, 'r', encoding="utf8") as csvfile:
        csvReader = csv.reader(csvfile, delimiter=DELIM)
        for row in csvReader:
            if row[0] == strSentFId:
                anom = row[1]
                policy = row[2]

    if text == "":
        return None
    else:
        labels = {
            "invalidity": anom,
            "policies": policy
        }
        sentJson = {
            "text": text,
            "labels": labels,
            "position": charOffset
        }
        return text, sentJson




def convertDataset(pathDir="", exportDir=""):

    # 1 check if all required file exist
    pathClProp = os.path.join(pathDir, "clauseProp.csv")
    pathClLabel = os.path.join(pathDir, "clauseClasses.csv")
    pathSeLabel = os.path.join(pathDir, "sentClasses.csv")
    pathTexts = os.path.join(pathDir, "texts")

    if not os.path.isfile(pathClProp) \
        or not os.path.isfile(pathClLabel) \
        or not os.path.isfile(pathSeLabel):
        return

    # Contracts indexed by name (store json, including title)
    contracts = {}


    # 2 Load files

    # Go through the clause property file
    # for each clause
    # check if parent contract dict was created, create it if not (with instance)
    # get clause annotation
    # get sentences of clause
    # for each sentence
    # add to clause text
    # get annotation and create subtext
    # add subtexts to clause
    # add clause text to clause
    # add clause to contract
    with open(pathClProp, 'r') as csvfile:
        csvReader = csv.reader(csvfile, delimiter=DELIM)
        for row in csvReader:
            clId = row[0]
            contTitle = row[1]
            clTitle = row[2]

            print(str(clId)+" "+str(contTitle)+" "+str(clTitle))

            if not contTitle in contracts:
                # Create a new json contract
                contracts[contTitle] = createJsonContract(contTitle)

            strClId = str(clId).zfill(4)
            sentNum = 1
            strSentNum = str(sentNum).zfill(3)

            clText = ""
            clSentList = []

            # While there is a file matching the sent id, add it !
            while os.path.isfile(os.path.join(pathTexts, strClId+"_"+strSentNum+".txt")):
                sentText, sentJson = loadSentence(clId, sentNum, pathTexts, pathSeLabel, len(clText))

                clText += sentText+" "
                clSentList.append(sentJson)

                sentNum += 1
                strSentNum = str(sentNum).zfill(3)

            # Load clause label
            anom = ""
            policy = ""
            clType = ""
            with open(pathClLabel, 'r') as csvfileLabel:
                csvReaderLabel = csv.reader(csvfileLabel, delimiter=DELIM)
                for rowLabel in csvReaderLabel:
                    if rowLabel[0] == str(clId):
                        anom = rowLabel[1]
                        policy = rowLabel[2]
                        clType = rowLabel[3]

            labels = {
                "invalidity": anom,
                "policies": policy,
                "type": clType
            }

            clJson = {
                "title": clTitle,
                "text": clText,
                "labels": labels,
                "subtexts": clSentList
            }

            # Add to contract
            contracts[contTitle]["instances"][0]["clauses"].append(clJson)


    # Export json documents
    print(contracts[" Agyla1"])

    for contId in contracts:
        exportName = str(contId)+".json"
        with open(os.path.join(exportDir, exportName), 'w', encoding='utf8') as fp:
            json.dump(contracts[contId], fp, ensure_ascii=False, indent=4)



if __name__ == "__main__":
    convertDataset("", "")